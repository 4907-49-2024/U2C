%! Author = Alex
%! Date = 2025-03-18

% Preamble
\documentclass[11pt]{article}

% Packages
\usepackage{amsmath}

% Document
\begin{document}

    \section{Technical Section - NAME TBD}
    This section will go over the technical specifications of our program, as well as the process behind building it.
    \subsection{Program Architecture}
    The architecture of our program refers to the structures used to reason about our program, and how they relate to each other.

    \subsubsection{Architecture Choice}
    % Should these terms be defined here, or earlier?
    For our particular problem, we believed a pipe and filter architectural pattern could apply very well. The general pattern is as follows: Data comes from a \textbf{source}, it is passed to a \textbf{pipe} which holds some immutable representation of that data while it remains in the pipe. From that point on, data from pipes are passed to \textbf{filters}. Filters take pipe data as input and outputs the transformed data to a different pipe. Thus, filter outputs can get chained as the next filter's inputs through pipes. Eventually, the final filter pipes its output to a \textbf{sink}, which represents the target data representation. From this point forward, we will refer to a \textbf{pipeline} as a function which takes a source as input, processes it with a predefined order of pipes and filters, then outputs a sink.\\

    This suitability of this architecture for our program becomes apparent when we start looking at its usual advantages and disadvantages.\\
    \textbf{Disadvantages:}
    \begin{itemize}
        \item Due to the independence of filters, pipe output/input need to be compatible.
        \item Difficult to coordinate, and synchronize. Unfit for asynchronous applications, like user interaction.
        \item Complex path branching logic difficult to implement due to limited information sharing.
    \end{itemize}
    \textbf{Advantages:}
    \begin{itemize}
        \item Loose coupling: can interchange filters with matching interfaces.
        \item Filters can be seen as black boxes, pipeline creation can ignore implementation of filters.
        \item Very easy to parallelize due to high independence.
        \item Re-usability: can re-use filters in different pipelines easily for different applications.
    \end{itemize}
    To put this in the context of our problem now, we have no user interaction in our system after the input is provided. We want to process our input diagrams, and eventually produce an output specification file. From this description, it already felt natural to try to make a pipeline, but there were many advantages from doing so. It opens the possibility to parallelize our processing easily, improving performance. The loose coupling also allows us to have redundant ways to compute certain pipes to include a model checker feature. Similarly, if we wanted to allow processing other diagram types as input, we could swap a subset of our current pipeline and re-use the rest. In general, it really helps for maintainability and extensibility of our program.

    \subsection{Main Structures}
    We will talk about the main structures of our architecture (pipes, filters, sinks, sources) in categories.
    This allows us to discuss what kind of filters could interchange in our existing filters
    rather than our current specific implementation.
    In section~\ref{subsec:main-pipeline}, we will map these categories to their concrete implementations in our current main pipeline.\\
    \textbf{Sources:}
    \begin{itemize}
        \item None (implicit) - In our prototype, to keep implementation it simple, the parser options are hardcoded and the inputs are all the files in the input folder.
    \end{itemize}
    \textbf{Pipes:}
    \begin{itemize}
        \item ParserConfig: This pipe type configures data required to find the input, and how to read it.
        \item RawInput: The input as read in by our parser.
        \item Diagrams: Pipes to represent a diagram type, diagrams may be further broken down into their components.
        \item C2KA: Pipes related to specific C2KA concepts, like behaviors, stimuli, and individual next-mappings.
        \item Specifications: Collections of other C2KA concepts building up a particular C2KA specification.
    \end{itemize}
    \textbf{Filters:}
    \begin{itemize}
        \item InputParser: Takes in an InputConfig, returns it as a RawInput.
        \item DiagramLinker: Takes in a RawInput, and returns it as a Diagram.
        \item DiagramInterpreter: Takes in a Diagram, returns a C2KA Specification.
    \end{itemize}
    \textbf{Sinks:}
    \begin{itemize}
        \item C2KA Specifications: We currently have a single sink which takes in all specification types
        and provides a method to output them to a file.
    \end{itemize}

    \subsection{Main Pipeline}\label{subsec:main-pipeline}

\end{document}